{"filter":false,"title":"minheap.cc","tooltip":"/minheap.cc","undoManager":{"stack":[[{"start":{"row":0,"column":0},"end":{"row":193,"column":2},"action":"insert","lines":["// Heap implementation","// The functionality is embedded into","// Heap abstract class to avoid code duplication","class Heap","{","public:","    // Initializes heap array and comparator required","    // in heapification","    Heap(int *b, bool (*c)(int, int)) : A(b), comp(c)","    {","        heapSize = -1;","    }"," ","    // Frees up dynamic memory","    virtual ~Heap()","    {","        if( A )","        {","            delete[] A;","        }","    }"," ","    // We need only these four interfaces of Heap ADT","    virtual bool Insert(int e) = 0;","    virtual int  GetTop() = 0;","    virtual int  ExtractTop() = 0;","    virtual int  GetCount() = 0;"," ","protected:"," ","    // We are also using location 0 of array","    int left(int i)","    {","        return 2 * i + 1;","    }"," ","    int right(int i)","    {","        return 2 * (i + 1);","    }"," ","    int parent(int i)","    {","        if( i <= 0 )","        {","            return -1;","        }"," ","        return (i - 1)/2;","    }"," ","    // Heap array","    int   *A;","    // Comparator","    bool  (*comp)(int, int);","    // Heap size","    int   heapSize;"," ","    // Returns top element of heap data structure","    int top(void)","    {","        int max = -1;"," ","        if( heapSize >= 0 )","        {","            max = A[0];","        }"," ","        return max;","    }"," ","    // Returns number of elements in heap","    int count()","    {","        return heapSize + 1;","    }"," ","    // Heapification","    // Note that, for the current median tracing problem","    // we need to heapify only towards root, always","    void heapify(int i)","    {","        int p = parent(i);"," ","        // comp - differentiate MaxHeap and MinHeap","        // percolates up","        if( p >= 0 && comp(A[i], A[p]) )","        {","            Exch(A[i], A[p]);","            heapify(p);","        }","    }"," ","    // Deletes root of heap","    int deleteTop()","    {","        int del = -1;"," ","        if( heapSize > -1)","        {","            del = A[0];"," ","            Exch(A[0], A[heapSize]);","            heapSize--;","            heapify(parent(heapSize+1));","        }"," ","        return del;","    }"," ","    // Helper to insert key into Heap","    bool insertHelper(int key)","    {","        bool ret = false;"," ","        if( heapSize < MAX_HEAP_SIZE )","        {","            ret = true;","            heapSize++;","            A[heapSize] = key;","            heapify(heapSize);","        }"," ","        return ret;","    }","};"," ","// Specilization of Heap to define MaxHeap","class MaxHeap : public Heap","{","private:"," ","public:","    MaxHeap() : Heap(new int[MAX_HEAP_SIZE], &Greater)  {  }"," ","    ~MaxHeap()  { }"," ","    // Wrapper to return root of Max Heap","    int GetTop()","    {","        return top();","    }"," ","    // Wrapper to delete and return root of Max Heap","    int ExtractTop()","    {","        return deleteTop();","    }"," ","    // Wrapper to return # elements of Max Heap","    int  GetCount()","    {","        return count();","    }"," ","    // Wrapper to insert into Max Heap","    bool Insert(int key)","    {","        return insertHelper(key);","    }","};","","class MinHeap : public Heap","{","private:"," ","public:"," ","    MinHeap() : Heap(new int[MAX_HEAP_SIZE], &Smaller) { }"," ","    ~MinHeap() { }"," ","    // Wrapper to return root of Min Heap","    int GetTop()","    {","        return top();","    }"," ","    // Wrapper to delete and return root of Min Heap","    int ExtractTop()","    {","        return deleteTop();","    }"," ","    int  GetCount()","    {","        return count();","    }"," ","    bool Insert(int key)","    {","        return insertHelper(key);","    }","};"],"id":1}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":0},"action":"insert","lines":["",""],"id":2}],[{"start":{"row":1,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["",""],"id":3}],[{"start":{"row":0,"column":0},"end":{"row":33,"column":1},"action":"insert","lines":["void Exch(int &a, int &b)","{","    int aux = a;","    a = b;","    b = aux;","}"," ","// Greater and Smaller are used as comparators","bool Greater(int a, int b)","{","    return a > b;","}"," ","bool Smaller(int a, int b)","{","    return a < b;","}"," ","int Average(int a, int b)","{","    return (a + b) / 2;","}"," ","// Signum function","// = 0  if a == b  - heaps are balanced","// = -1 if a < b   - left contains less elements than right","// = 1  if a > b   - left contains more elements than right","int Signum(int a, int b)","{","    if( a == b )","        return 0;"," ","    return a < b ? -1 : 1;","}"],"id":4}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":0},"action":"insert","lines":["",""],"id":5}],[{"start":{"row":1,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["",""],"id":6}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":27},"action":"insert","lines":["","#define MAX_HEAP_SIZE (128)"],"id":7}],[{"start":{"row":0,"column":0},"end":{"row":1,"column":0},"action":"remove","lines":["",""],"id":8}],[{"start":{"row":1,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["",""],"id":9}],[{"start":{"row":2,"column":0},"end":{"row":2,"column":1},"action":"insert","lines":["i"],"id":10}],[{"start":{"row":2,"column":1},"end":{"row":2,"column":2},"action":"insert","lines":["n"],"id":11}],[{"start":{"row":2,"column":2},"end":{"row":2,"column":3},"action":"insert","lines":["l"],"id":12}],[{"start":{"row":2,"column":3},"end":{"row":2,"column":4},"action":"insert","lines":["i"],"id":13}],[{"start":{"row":2,"column":4},"end":{"row":2,"column":5},"action":"insert","lines":["n"],"id":14}],[{"start":{"row":2,"column":5},"end":{"row":2,"column":6},"action":"insert","lines":["e"],"id":15}],[{"start":{"row":10,"column":0},"end":{"row":10,"column":46},"action":"remove","lines":["// Greater and Smaller are used as comparators"],"id":16}],[{"start":{"row":9,"column":1},"end":{"row":10,"column":0},"action":"remove","lines":["",""],"id":17}],[{"start":{"row":37,"column":0},"end":{"row":39,"column":48},"action":"remove","lines":["// Heap implementation","// The functionality is embedded into","// Heap abstract class to avoid code duplication"],"id":18}],[{"start":{"row":36,"column":0},"end":{"row":37,"column":0},"action":"remove","lines":["",""],"id":19}],[{"start":{"row":47,"column":0},"end":{"row":47,"column":30},"action":"remove","lines":["    // Frees up dynamic memory"],"id":20}],[{"start":{"row":46,"column":1},"end":{"row":47,"column":0},"action":"remove","lines":["",""],"id":21}],[{"start":{"row":40,"column":0},"end":{"row":41,"column":23},"action":"remove","lines":["    // Initializes heap array and comparator required","    // in heapification"],"id":22}],[{"start":{"row":54,"column":0},"end":{"row":54,"column":53},"action":"remove","lines":["    // We need only these four interfaces of Heap ADT"],"id":23}],[{"start":{"row":53,"column":1},"end":{"row":54,"column":0},"action":"remove","lines":["",""],"id":24}],[{"start":{"row":61,"column":0},"end":{"row":61,"column":44},"action":"remove","lines":["    // We are also using location 0 of array"],"id":25}],[{"start":{"row":60,"column":1},"end":{"row":61,"column":0},"action":"remove","lines":["",""],"id":26}],[{"start":{"row":81,"column":0},"end":{"row":81,"column":17},"action":"remove","lines":["    // Heap array"],"id":27}],[{"start":{"row":80,"column":1},"end":{"row":81,"column":0},"action":"remove","lines":["",""],"id":28}],[{"start":{"row":82,"column":0},"end":{"row":82,"column":17},"action":"remove","lines":["    // Comparator"],"id":29}],[{"start":{"row":81,"column":13},"end":{"row":82,"column":0},"action":"remove","lines":["",""],"id":30}],[{"start":{"row":83,"column":0},"end":{"row":83,"column":16},"action":"remove","lines":["    // Heap size"],"id":31}],[{"start":{"row":82,"column":28},"end":{"row":83,"column":0},"action":"remove","lines":["",""],"id":32}],[{"start":{"row":85,"column":0},"end":{"row":85,"column":49},"action":"remove","lines":["    // Returns top element of heap data structure"],"id":33}],[{"start":{"row":84,"column":1},"end":{"row":85,"column":0},"action":"remove","lines":["",""],"id":34}],[{"start":{"row":97,"column":0},"end":{"row":97,"column":41},"action":"remove","lines":["    // Returns number of elements in heap"],"id":35}],[{"start":{"row":96,"column":1},"end":{"row":97,"column":0},"action":"remove","lines":["",""],"id":36}],[{"start":{"row":102,"column":0},"end":{"row":104,"column":51},"action":"remove","lines":["    // Heapification","    // Note that, for the current median tracing problem","    // we need to heapify only towards root, always"],"id":37}],[{"start":{"row":101,"column":1},"end":{"row":102,"column":0},"action":"remove","lines":["",""],"id":38}],[{"start":{"row":115,"column":0},"end":{"row":115,"column":27},"action":"remove","lines":["    // Deletes root of heap"],"id":39}],[{"start":{"row":114,"column":1},"end":{"row":115,"column":0},"action":"remove","lines":["",""],"id":40}],[{"start":{"row":131,"column":0},"end":{"row":131,"column":37},"action":"remove","lines":["    // Helper to insert key into Heap"],"id":41}],[{"start":{"row":130,"column":1},"end":{"row":131,"column":0},"action":"remove","lines":["",""],"id":42}],[{"start":{"row":147,"column":0},"end":{"row":147,"column":42},"action":"remove","lines":["// Specilization of Heap to define MaxHeap"],"id":43}],[{"start":{"row":146,"column":1},"end":{"row":147,"column":0},"action":"remove","lines":["",""],"id":44}],[{"start":{"row":155,"column":0},"end":{"row":156,"column":41},"action":"remove","lines":[" ","    // Wrapper to return root of Max Heap"],"id":45}],[{"start":{"row":161,"column":0},"end":{"row":161,"column":52},"action":"remove","lines":["    // Wrapper to delete and return root of Max Heap"],"id":46}],[{"start":{"row":160,"column":1},"end":{"row":161,"column":0},"action":"remove","lines":["",""],"id":47}],[{"start":{"row":166,"column":0},"end":{"row":166,"column":47},"action":"remove","lines":["    // Wrapper to return # elements of Max Heap"],"id":48}],[{"start":{"row":165,"column":1},"end":{"row":166,"column":0},"action":"remove","lines":["",""],"id":49}],[{"start":{"row":170,"column":0},"end":{"row":171,"column":38},"action":"remove","lines":[" ","    // Wrapper to insert into Max Heap"],"id":50}],[{"start":{"row":187,"column":0},"end":{"row":187,"column":41},"action":"remove","lines":["    // Wrapper to return root of Min Heap"],"id":51}],[{"start":{"row":186,"column":1},"end":{"row":187,"column":0},"action":"remove","lines":["",""],"id":52}],[{"start":{"row":191,"column":0},"end":{"row":192,"column":52},"action":"remove","lines":[" ","    // Wrapper to delete and return root of Min Heap"],"id":53}],[{"start":{"row":25,"column":0},"end":{"row":28,"column":59},"action":"remove","lines":["// Signum function","// = 0  if a == b  - heaps are balanced","// = -1 if a < b   - left contains less elements than right","// = 1  if a > b   - left contains more elements than right"],"id":54}],[{"start":{"row":24,"column":1},"end":{"row":25,"column":0},"action":"remove","lines":["",""],"id":55}],[{"start":{"row":37,"column":50},"end":{"row":37,"column":51},"action":"insert","lines":["a"],"id":56}],[{"start":{"row":37,"column":51},"end":{"row":37,"column":52},"action":"insert","lines":["r"],"id":57}],[{"start":{"row":37,"column":52},"end":{"row":37,"column":53},"action":"insert","lines":["e"],"id":58}],[{"start":{"row":37,"column":53},"end":{"row":37,"column":54},"action":"insert","lines":["r"],"id":59}],[{"start":{"row":37,"column":53},"end":{"row":37,"column":54},"action":"remove","lines":["r"],"id":60}],[{"start":{"row":37,"column":52},"end":{"row":37,"column":53},"action":"remove","lines":["e"],"id":61}],[{"start":{"row":37,"column":51},"end":{"row":37,"column":52},"action":"remove","lines":["r"],"id":62}],[{"start":{"row":37,"column":50},"end":{"row":37,"column":51},"action":"remove","lines":["a"],"id":63}],[{"start":{"row":102,"column":0},"end":{"row":103,"column":24},"action":"remove","lines":["        // comp - differentiate MaxHeap and MinHeap","        // percolates up"],"id":64}],[{"start":{"row":101,"column":1},"end":{"row":102,"column":0},"action":"remove","lines":["",""],"id":65}],[{"start":{"row":37,"column":50},"end":{"row":37,"column":51},"action":"insert","lines":["a"],"id":66}],[{"start":{"row":37,"column":51},"end":{"row":37,"column":52},"action":"insert","lines":["r"],"id":67}],[{"start":{"row":37,"column":52},"end":{"row":37,"column":53},"action":"insert","lines":["e"],"id":68}],[{"start":{"row":37,"column":53},"end":{"row":37,"column":54},"action":"insert","lines":["r"],"id":69}],[{"start":{"row":78,"column":16},"end":{"row":78,"column":17},"action":"insert","lines":["a"],"id":70}],[{"start":{"row":78,"column":17},"end":{"row":78,"column":18},"action":"insert","lines":["r"],"id":71}],[{"start":{"row":78,"column":18},"end":{"row":78,"column":19},"action":"insert","lines":["e"],"id":72}],[{"start":{"row":78,"column":19},"end":{"row":78,"column":20},"action":"insert","lines":["r"],"id":73}],[{"start":{"row":102,"column":26},"end":{"row":102,"column":27},"action":"insert","lines":["a"],"id":74}],[{"start":{"row":102,"column":27},"end":{"row":102,"column":28},"action":"insert","lines":["r"],"id":75}],[{"start":{"row":102,"column":28},"end":{"row":102,"column":29},"action":"insert","lines":["e"],"id":76}],[{"start":{"row":102,"column":29},"end":{"row":102,"column":30},"action":"insert","lines":["r"],"id":77}]],"mark":76,"position":76},"ace":{"folds":[],"scrolltop":154.5,"scrollleft":0,"selection":{"start":{"row":57,"column":19},"end":{"row":57,"column":19},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":295,"mode":"ace/mode/c_cpp"}},"timestamp":1432392272171,"hash":"33346f8fbb965e16e14e533ea99fbc556ae34b6b"}